package vcs

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"os/exec"

	gogit "github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
)

const indexRef = "localindex"
const autoGeneratedAttribute = "linguist-generated"

func init() {
	Register(newGit, "git")
}

type GitDriver struct {
	Ref  string `json:"ref"`
	Bare bool   `json:"bare"`
}

func newGit(b []byte) (Driver, error) {
	var d GitDriver

	if b != nil {
		if err := json.Unmarshal(b, &d); err != nil {
			return nil, err
		}
	}

	return &d, nil
}

func (g *GitDriver) Pull(dir string) (string, error) {
	repo, err := gogit.PlainOpen(dir)
	if err != nil {
		return "", fmt.Errorf("failed to open repository: %w", err)
	}

	fetchTarget := "HEAD"
	if g.Ref != "" {
		fetchTarget = g.Ref
	}

	if err = repo.Fetch(&gogit.FetchOptions{
		Depth: 1,
		Prune: true,
		Tags:  gogit.NoTags,
		RefSpecs: []config.RefSpec{
			config.RefSpec(fmt.Sprintf("+%s:refs/heads/%s", fetchTarget, indexRef)),
		},
	}); err != nil {
		return "", fmt.Errorf("failed to pull: %w", err)
	}

	newHead, err := repo.ResolveRevision(indexRef)
	if err != nil {
		return "", fmt.Errorf("failed to resolve revision: %w", err)
	}

	if !g.Bare {
		worktree, err := repo.Worktree()
		if err != nil {
			return "", fmt.Errorf("failed to reset worktree: %w", err)
		}
		worktree.Reset(&gogit.ResetOptions{
			Mode:   gogit.HardReset,
			Commit: *newHead,
		})
	}

	return newHead.String(), nil
}

func (g *GitDriver) Clone(dir, url string) (string, error) {
	_, err := gogit.PlainClone(dir, g.Bare, &gogit.CloneOptions{
		Depth: 1,
		URL:   url,
	})
	if err != nil {
		return "", fmt.Errorf("failed to clone %s: %w", url, err)
	}

	return g.Pull(dir)
}

func (g *GitDriver) SpecialFiles() []string {
	return []string{
		".git",
	}
}

func (g *GitDriver) AutoGeneratedFiles(dir string) []string {
	var files []string

	// XXX(tvdw): broken under Bare
	if g.Bare {
		return nil
	}

	filesCmd := exec.Command("git", "ls-files", "-z")
	filesCmd.Dir = dir
	pipe, err := filesCmd.StdoutPipe()

	if err != nil {
		log.Printf("Error occured when running git ls-files in %s: %s.", dir, err)
		return files
	}

	if err := filesCmd.Start(); err != nil {
		log.Printf("Error occured when running git ls-files in %s: %s.", dir, err)
		return files
	}

	attributesCmd := exec.Command("git", "check-attr", "--stdin", "-z", autoGeneratedAttribute)
	attributesCmd.Dir = dir
	attributesCmd.Stdin = pipe

	out, err := attributesCmd.Output()

	if err != nil {
		log.Printf("Error occured when running git check-attr in %s: %s.", dir, err)
		return files
	}

	// Split by NUL and we expect the format: <path> NUL <attribute> NUL <info> NUL
	tokens := bytes.Split(out, []byte{0})

	for i := 2; i < len(tokens); i += 3 {
		if string(tokens[i]) == "true" && string(tokens[i-1]) == autoGeneratedAttribute {
			files = append(files, string(tokens[i-2]))
		}
	}

	if err := filesCmd.Wait(); err != nil {
		log.Printf("Error occured when running git ls-files in %s: %s.", dir, err)
		return files
	}

	return files
}

func (g *GitDriver) FileSystem(dir string) (FileSystem, error) {
	if g.Bare {
		return NewGitFilesystem(dir, indexRef)
	} else {
		return NewDirFilesystem(dir)
	}
}
